# 효율적인 화폐 구성
## 문제
N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다. 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.

## 입력
첫째 줄에 N,M이 주어진다(1<= N <= 100, 1<= M <= 10,000)
이후의 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000보다 작거나 같은 자연수이다.
## 출력
첫째 줄에 경우의 수 X를 출력한다.(불가능할 때는 -1을 출력한다)
### 입력 예시
```
2 15
2
3
```
### 출력 예시
```
5
```

## 풀이 
화폐의 가치가 배수관계라면 큰 수부터 최대한으로 나눠주면 되지만, 이 문제는 배수관계가 아니라 그리디 알고리즘이 아닌 다이나믹 프로그래밍 알고리즘으로 접근해야 한다.  
다이나믹 프로그래밍의 핵심은 점화식이다. 점화식을 찾아보자.  
우선 화폐의 갯수가 1개라고 가정한다면 dp[i] = dp[i - (화폐 가치)]일 것이다.  
그럼 두개 이상일 때는 어떻게 할까?  
생각해보면 간단하다. 우선 화폐 하나로 계산을 끝낸 후 다음 화폐를 사용했을 때와 비교해서 최솟값을 구하면 되는 것이다.  
즉 1번 화폐를 통해 dp를 계산한 후, 그 메모리(dp)를 사용하여 다음 화폐를 사용했을 때의 최솟값을 구한다.  


dp[i] = min(dp[i], dp[i - (화폐의 가치)])  


dp[i]와 dp[i - (화폐의 가치)]를 비교하는 이유는 현재 화폐를 사용하지 않고 최솟값을 구하는 경우도 존재하기 때문이다.

## 코드
```
n, m = list(map(int, input().split()))

arr = [0] * n
for i in range (n):
  arr[i] = int(input())

dp = [10001] * (m + 1)
dp[0] = 0

for i in arr:
  for j in range(i, m+1):
    if dp[j - i] != 10001:
      dp[j] = min(dp[j], dp[j-i] + 1)

if dp[m] == 10001:
  print(-1)
else:
  print(dp[m])

```
